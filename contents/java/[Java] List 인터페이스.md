## List
리스트 인터페이스는 대표적인 선형 자료구조로 주로 순서가 있는 데이터를 목록으로 이용할 수 있도록 만들어진 인터페이스다.  
배열을 슬때 int[] array = new int[10]; 처럼 쓴다. 하지만, 이 처럼 선언한 배열의 경우  
10개의 공간 외에는 더 이상 사용하지 못한다. 즉, arrary[13] = 32;라고 해주더라도 할당된 크기(범위) 밖이기 때문에   
`IndexOutofBoundsException` 이라는 에러가 발생한다. 

이러한 단점을 보완하여 List를 통해 구현된 클래스들은 `동적 크기` 를 갖으며 배열처럼 사용할 수 있게 되어있다.  
한마디로 배열의 기능 + 동적 크기 할당이 합쳐져 있다고 보면 된다.

### List Interface를 구현하는 클래스
**1.ArrayList**   
**2.LinkedList**     
**3.Vector(+Vector를 상속받은 Stack)**     


**List interface에 선언된 대표적인 메소드**  
<br/>
![리스트](https://user-images.githubusercontent.com/60098769/145828741-8384e28b-1435-4708-b8e8-0ad7b8691107.png)

<br/>

**`ArrayList`**
는 Object[] 배열을 사용하면서 내부 구현을 통해 동적으로 관리를 한다.  
우리가 흔히 쓰는 primitive 배열(ex int[])과 유사한 형태라고 보면 된다.  
즉, 최상위 타입인 Object 타입으로 배열을 생성하여 사용하기 때문에 요소 접근(access elements)에서는 탁월한 성능을 보이나,   
중간의 요소가 삽입, 삭제가 일어나는 경우 그 뒤의 요소들은 한 칸씩 밀어야 하거나 당겨야 하기 때문에 삽입, 삭제에서는 비효율적인 모습을 보인다. 


<br/><br/>


**`LinkedList`**
는 데이터(item)와 주소로 이루어진 클래스를 만들어 서로 연결하는 방식이다.     
데이터와 주소로 이루어진 클래스를 Node(노드)라고 하는데, 각 노드는 이전의 노드와 다음 노드를 연결하는 방식인 것이다.(이중 연결 리스트라고도 한다.)     
즉, 객체끼리 연결한 방식이다. 이렇다보니 요소를 검색해야 할 경우 처음 노드부터 찾으려는 노드가 나올 때 까지 연결된 노드들을 모두 방문해야한다는 점에서 성능이 떨어지나,     
해당 노드를 삭제, 삽입해야 할 경우 해당 노드의 링크를 끊거나 연결만 해주면 되기 때문에 삽입, 삭제에서는 매우 좋은 효율을 보인다.    
 
<br/><br/>


**`Vector`**
는 자바를 배울 때 그리 자주 보이지는 않는 클래스인데, 기본적으로 ArrayList와 거의 같다고 보면 된다.    
Object[] 배열을 사용하며 요소 접근에서 빠른 성능을 보인다. 근데 왜 Vector가 있는 것이냐?라고 한다면, 원래 Vector는 Collection Framwork가 도입되기 전부터 지원하던 클래스였다.     
그리고 Vector의 경우 항상 '동기화'를 지원한다. (쉽게 말하면 여러 쓰레드가 동시에 데이터에 접근하려하면 순차적으로 처리하도록 한다.)     
그렇다보니 멀티 쓰레드에서는 안전하지만, 단일 쓰레드에서도 동기화를 하기 때문에 ArrayList에 비해 성능이 약간 느리다.  
  
